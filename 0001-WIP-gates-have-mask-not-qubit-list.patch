From 80143a685527da742234597e8550f30d232ee3f0 Mon Sep 17 00:00:00 2001
From: gandalfr-KY <oukanimiso@gmail.com>
Date: Fri, 19 Jul 2024 04:11:35 +0000
Subject: [PATCH] WIP: gates have mask, not qubit list

---
 exe/main.cpp                                  | 107 +++++++-
 scaluq/CMakeLists.txt                         |   2 -
 scaluq/gate/gate.hpp                          |  30 ++-
 scaluq/gate/gate_factory.hpp                  | 171 ++++++++-----
 scaluq/gate/gate_matrix.hpp                   |  30 +--
 scaluq/gate/gate_npair_qubit.hpp              |  61 -----
 scaluq/gate/gate_one_control_one_target.hpp   |  62 -----
 scaluq/gate/gate_one_qubit.hpp                | 231 +++++++++---------
 scaluq/gate/gate_pauli.hpp                    |  29 +--
 scaluq/gate/gate_probablistic.hpp             |  39 +--
 scaluq/gate/gate_two_qubit.hpp                |  22 +-
 scaluq/gate/gate_zero_qubit.hpp               |  27 +-
 scaluq/gate/param_gate.hpp                    |  23 +-
 scaluq/gate/param_gate_factory.hpp            |  23 +-
 scaluq/gate/param_gate_one_qubit.hpp          |  42 ++--
 scaluq/gate/param_gate_pauli.hpp              |  13 +-
 scaluq/gate/param_gate_probablistic.hpp       |  47 ++--
 scaluq/gate/update_ops.hpp                    |  82 +++----
 scaluq/gate/update_ops_dense_matrix.cpp       |  27 +-
 scaluq/gate/update_ops_npair_qubit.cpp        |  37 ---
 .../update_ops_one_control_one_target.cpp     |  34 ---
 scaluq/gate/update_ops_one_qubit.cpp          | 107 ++++----
 scaluq/gate/update_ops_pauli.cpp              |  12 +-
 scaluq/gate/update_ops_quantum_matrix.cpp     |  19 +-
 scaluq/gate/update_ops_two_qubit.cpp          |  13 +-
 scaluq/gate/update_ops_zero_qubit.cpp         |   9 +-
 scaluq/util/utility.hpp                       |  29 +++
 27 files changed, 664 insertions(+), 664 deletions(-)
 delete mode 100644 scaluq/gate/gate_npair_qubit.hpp
 delete mode 100644 scaluq/gate/gate_one_control_one_target.hpp
 delete mode 100644 scaluq/gate/update_ops_npair_qubit.cpp
 delete mode 100644 scaluq/gate/update_ops_one_control_one_target.cpp

diff --git a/exe/main.cpp b/exe/main.cpp
index 1fefff4..28680a9 100644
--- a/exe/main.cpp
+++ b/exe/main.cpp
@@ -12,13 +12,110 @@
 using namespace scaluq;
 using namespace std;
 
-void run() {
-    UINT n_qubits = 5;
-    auto state = StateVector::Haar_random_state(n_qubits);
-}
+// KOKKOS_INLINE_FUNCTION UINT insert_zero_to_basis_index(UINT basis_index, UINT insert_index) {
+//     UINT mask = (1ULL << insert_index) - 1;
+//     UINT temp_basis = (basis_index >> insert_index) << (insert_index + 1);
+//     return temp_basis | (basis_index & mask);
+// }
+
+// KOKKOS_INLINE_FUNCTION UINT insert_zero_at_mask_positions(UINT basis_index, UINT insert_mask) {
+//     for (UINT bit_mask = insert_mask; bit_mask;
+//          bit_mask &= (bit_mask - 1)) {  // loop through set bits
+//         UINT lower_mask = ~bit_mask & (bit_mask - 1);
+//         UINT upper_mask = ~lower_mask;
+//         basis_index = ((basis_index & upper_mask) << 1) | (basis_index & lower_mask);
+//     }
+//     return basis_index;
+// }
+
+// void x_gate(UINT target_qubit_index, StateVector& state) {
+//     Kokkos::parallel_for(
+//         state.dim() >> 1, KOKKOS_LAMBDA(UINT it) {
+//             UINT i = insert_zero_to_basis_index(it, target_qubit_index);
+//             Kokkos::Experimental::swap(state._raw[i], state._raw[i | (1ULL <<
+//             target_qubit_index)]);
+//         });
+//     Kokkos::fence();
+// }
+
+// void cx_gate(UINT target_qubit_index, UINT control_qubit_index, StateVector& state) {
+//     Kokkos::parallel_for(
+//         state.dim() >> 2, KOKKOS_LAMBDA(UINT it) {
+//             UINT i =
+//                 internal::insert_zero_to_basis_index(it, target_qubit_index,
+//                 control_qubit_index);
+//             i |= 1ULL << control_qubit_index;
+//             Kokkos::Experimental::swap(state._raw[i], state._raw[i | (1ULL <<
+//             target_qubit_index)]);
+//         });
+//     Kokkos::fence();
+// }
+
+// void x_gate_control(UINT target_mask, UINT control_mask, StateVector& state) {
+//     Kokkos::parallel_for(
+//         state.dim() >> (1 + std::popcount(control_mask)), KOKKOS_LAMBDA(UINT it) {
+//             UINT i = insert_zero_at_mask_positions(it, control_mask | target_mask) |
+//             control_mask; Kokkos::Experimental::swap(state._raw[i], state._raw[i | target_mask]);
+//         });
+//     Kokkos::fence();
+// }
+
+// void run() {
+//     const UINT n_qubits = 25, loop = 50;
+
+//     std::vector<UINT> target, control;
+//     Random rd;
+//     for (UINT i = 0; i < loop; ++i) {
+//         target.push_back(rd.int32() % n_qubits);
+//         control.push_back(rd.int32() % n_qubits);
+//     }
+
+//     {  // warm up
+//         auto state = StateVector::Haar_random_state(n_qubits);
+//         for (UINT i = 0; i < loop; ++i) {
+//             x_gate(target[i], state);
+//         }
+//     }
+
+//     {
+//         auto state1 = StateVector::Haar_random_state(n_qubits);
+//         Kokkos::Timer tm;
+//         for (UINT i = 0; i < loop; ++i) {
+//             x_gate(target[i], state1);
+//         }
+//         std::cout << "x_gate            : " << tm.seconds() << std::endl;
+
+//         auto state2 = StateVector::Haar_random_state(n_qubits);
+//         tm.reset();
+//         for (UINT i = 0; i < loop; ++i) {
+//             x_gate_control(1ULL << target[i], 0, state2);
+//         }
+//         std::cout << "controlable x_gate: " << tm.seconds() << std::endl;
+
+//         assert(state1.amplitudes() == state2.amplitudes());
+//     }
+
+//     {
+//         auto state1 = StateVector::Haar_random_state(n_qubits);
+//         Kokkos::Timer tm;
+//         for (UINT i = 0; i < loop; ++i) {
+//             cx_gate(target[i], control[i], state1);
+//         }
+//         std::cout << "cx_gate           : " << tm.seconds() << std::endl;
+
+//         auto state2 = StateVector::Haar_random_state(n_qubits);
+//         tm.reset();
+//         for (UINT i = 0; i < loop; ++i) {
+//             x_gate_control(1ULL << target[i], 1ULL << control[i], state2);
+//         }
+//         std::cout << "controlable x_gate: " << tm.seconds() << std::endl;
+
+//         assert(state1.amplitudes() == state2.amplitudes());
+//     }
+// }
 
 int main() {
     Kokkos::initialize();
-    run();
+    // run();
     Kokkos::finalize();
 }
diff --git a/scaluq/CMakeLists.txt b/scaluq/CMakeLists.txt
index 6392fef..47d976a 100644
--- a/scaluq/CMakeLists.txt
+++ b/scaluq/CMakeLists.txt
@@ -3,8 +3,6 @@ cmake_minimum_required(VERSION 3.21)
 target_sources(scaluq PRIVATE
     circuit/circuit.cpp
     gate/update_ops_dense_matrix.cpp
-    gate/update_ops_npair_qubit.cpp
-    gate/update_ops_one_control_one_target.cpp
     gate/update_ops_one_qubit.cpp
     gate/update_ops_pauli.cpp
     gate/update_ops_quantum_matrix.cpp
diff --git a/scaluq/gate/gate.hpp b/scaluq/gate/gate.hpp
index 5162b61..524b7a0 100644
--- a/scaluq/gate/gate.hpp
+++ b/scaluq/gate/gate.hpp
@@ -2,6 +2,7 @@
 
 #include "../state/state_vector.hpp"
 #include "../types.hpp"
+#include "../util/utility.hpp"
 #include "update_ops.hpp"
 
 namespace scaluq {
@@ -124,11 +125,36 @@ constexpr GateType get_gate_type() {
 
 namespace internal {
 class GateBase {
+protected:
+    UINT _target_mask, _control_mask;
+    void check_qubit_mask_within_bounds(StateVector& state_vector) const {
+        UINT full_mask = (1ULL << state_vector.n_qubits()) - 1;
+        if ((_target_mask | _control_mask) > full_mask) [[unlikely]] {
+            throw std::runtime_error(
+                "Error: Gate::update_quantum_state(StateVector& state): "
+                "Target/Control qubit exceeds the number of qubits in the system.");
+        }
+    }
+
 public:
+    GateBase(UINT target_mask, UINT control_mask)
+        : _target_mask(target_mask), _control_mask(control_mask) {
+        if (_target_mask & _control_mask) [[unlikely]] {
+            throw std::runtime_error(
+                "Error: Gate::Gate(UINT target_mask, UINT control_mask) : Target and "
+                "control qubits must not overlap.");
+        }
+    }
     virtual ~GateBase() = default;
 
-    [[nodiscard]] virtual std::vector<UINT> get_target_qubit_list() const = 0;
-    [[nodiscard]] virtual std::vector<UINT> get_control_qubit_list() const = 0;
+    [[nodiscard]] std::vector<UINT> get_target_qubit_list() const {
+        return mask_to_vector(_target_mask);
+    }
+    [[nodiscard]] std::vector<UINT> get_control_qubit_list() const {
+        return mask_to_vector(_control_mask);
+    }
+    [[nodiscard]] UINT get_target_qubit_mask() const { return _target_mask; }
+    [[nodiscard]] UINT get_control_qubit_mask() const { return _control_mask; }
 
     [[nodiscard]] virtual Gate get_inverse() const = 0;
     [[nodiscard]] virtual std::optional<ComplexMatrix> get_matrix() const = 0;
diff --git a/scaluq/gate/gate_factory.hpp b/scaluq/gate/gate_factory.hpp
index 3728ead..9eb752d 100644
--- a/scaluq/gate/gate_factory.hpp
+++ b/scaluq/gate/gate_factory.hpp
@@ -1,8 +1,6 @@
 #pragma once
 
 #include "gate_matrix.hpp"
-#include "gate_npair_qubit.hpp"
-#include "gate_one_control_one_target.hpp"
 #include "gate_one_qubit.hpp"
 #include "gate_pauli.hpp"
 #include "gate_probablistic.hpp"
@@ -21,115 +19,155 @@ public:
 }  // namespace internal
 namespace gate {
 inline Gate I() { return internal::GateFactory::create_gate<internal::IGateImpl>(); }
-inline Gate GlobalPhase(double phase) {
-    return internal::GateFactory::create_gate<internal::GlobalPhaseGateImpl>(phase);
+inline Gate GlobalPhase(const std::vector<UINT>& control_qubits, double phase) {
+    return internal::GateFactory::create_gate<internal::GlobalPhaseGateImpl>(
+        internal::vector_to_mask(control_qubits), phase);
 }
-inline Gate X(UINT target) {
-    return internal::GateFactory::create_gate<internal::XGateImpl>(target);
+inline Gate X(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::XGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate Y(UINT target) {
-    return internal::GateFactory::create_gate<internal::YGateImpl>(target);
+inline Gate Y(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::YGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate Z(UINT target) {
-    return internal::GateFactory::create_gate<internal::ZGateImpl>(target);
+inline Gate Z(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::ZGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate H(UINT target) {
-    return internal::GateFactory::create_gate<internal::HGateImpl>(target);
+inline Gate H(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::HGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate S(UINT target) {
-    return internal::GateFactory::create_gate<internal::SGateImpl>(target);
+inline Gate S(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::SGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate Sdag(UINT target) {
-    return internal::GateFactory::create_gate<internal::SdagGateImpl>(target);
+inline Gate Sdag(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::SdagGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate T(UINT target) {
-    return internal::GateFactory::create_gate<internal::TGateImpl>(target);
+inline Gate T(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::TGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate Tdag(UINT target) {
-    return internal::GateFactory::create_gate<internal::TdagGateImpl>(target);
+inline Gate Tdag(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::TdagGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate SqrtX(UINT target) {
-    return internal::GateFactory::create_gate<internal::SqrtXGateImpl>(target);
+inline Gate SqrtX(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::SqrtXGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate SqrtXdag(UINT target) {
-    return internal::GateFactory::create_gate<internal::SqrtXdagGateImpl>(target);
+inline Gate SqrtXdag(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::SqrtXdagGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate SqrtY(UINT target) {
-    return internal::GateFactory::create_gate<internal::SqrtYGateImpl>(target);
+inline Gate SqrtY(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::SqrtYGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate SqrtYdag(UINT target) {
-    return internal::GateFactory::create_gate<internal::SqrtYdagGateImpl>(target);
+inline Gate SqrtYdag(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::SqrtYdagGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate P0(UINT target) {
-    return internal::GateFactory::create_gate<internal::P0GateImpl>(target);
+inline Gate P0(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::P0GateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate P1(UINT target) {
-    return internal::GateFactory::create_gate<internal::P1GateImpl>(target);
+inline Gate P1(UINT target, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::P1GateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls));
 }
-inline Gate RX(UINT target, double angle) {
-    return internal::GateFactory::create_gate<internal::RXGateImpl>(target, angle);
+inline Gate RX(UINT target, const std::vector<UINT>& controls, double angle) {
+    return internal::GateFactory::create_gate<internal::RXGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls), angle);
 }
-inline Gate RY(UINT target, double angle) {
-    return internal::GateFactory::create_gate<internal::RYGateImpl>(target, angle);
+inline Gate RY(UINT target, const std::vector<UINT>& controls, double angle) {
+    return internal::GateFactory::create_gate<internal::RYGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls), angle);
 }
-inline Gate RZ(UINT target, double angle) {
-    return internal::GateFactory::create_gate<internal::RZGateImpl>(target, angle);
+inline Gate RZ(UINT target, const std::vector<UINT>& controls, double angle) {
+    return internal::GateFactory::create_gate<internal::RZGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls), angle);
 }
-inline Gate U1(UINT target, double lambda) {
-    return internal::GateFactory::create_gate<internal::U1GateImpl>(target, lambda);
+inline Gate U1(UINT target, const std::vector<UINT>& controls, double lambda) {
+    return internal::GateFactory::create_gate<internal::U1GateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls), lambda);
 }
-inline Gate U2(UINT target, double phi, double lambda) {
-    return internal::GateFactory::create_gate<internal::U2GateImpl>(target, phi, lambda);
+inline Gate U2(UINT target, const std::vector<UINT>& controls, double phi, double lambda) {
+    return internal::GateFactory::create_gate<internal::U2GateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls), phi, lambda);
 }
-inline Gate U3(UINT target, double theta, double phi, double lambda) {
-    return internal::GateFactory::create_gate<internal::U3GateImpl>(target, theta, phi, lambda);
+inline Gate U3(
+    UINT target, const std::vector<UINT>& controls, double theta, double phi, double lambda) {
+    return internal::GateFactory::create_gate<internal::U3GateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls), theta, phi, lambda);
 }
-inline Gate OneQubitMatrix(UINT target, const std::array<std::array<Complex, 2>, 2>& matrix) {
-    return internal::GateFactory::create_gate<internal::OneQubitMatrixGateImpl>(target, matrix);
+inline Gate OneQubitMatrix(UINT target,
+                           const std::vector<UINT>& controls,
+                           const std::array<std::array<Complex, 2>, 2>& matrix) {
+    return internal::GateFactory::create_gate<internal::OneQubitMatrixGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls), matrix);
 }
-inline Gate CX(UINT control, UINT target) {
-    return internal::GateFactory::create_gate<internal::CXGateImpl>(control, target);
+inline Gate CX(UINT target, UINT control) {
+    return internal::GateFactory::create_gate<internal::XGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask({control}));
 }
 inline auto& CNot = CX;
-inline Gate CZ(UINT control, UINT target) {
-    return internal::GateFactory::create_gate<internal::CZGateImpl>(control, target);
+inline Gate CZ(UINT target, UINT control) {
+    return internal::GateFactory::create_gate<internal::ZGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask({control}));
 }
-inline Gate Swap(UINT target1, UINT target2) {
-    return internal::GateFactory::create_gate<internal::SwapGateImpl>(target1, target2);
+inline Gate Toffoli(UINT target, UINT control1, UINT control2) {
+    return internal::GateFactory::create_gate<internal::XGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask({control1, control2}));
 }
-inline Gate FusedSwap(UINT qubit_index1, UINT qubit_index2, UINT block_size) {
-    return internal::GateFactory::create_gate<internal::FusedSwapGateImpl>(
-        qubit_index1, qubit_index2, block_size);
+inline auto& CCNot = Toffoli;
+inline Gate Swap(UINT target1, UINT target2, const std::vector<UINT>& controls) {
+    return internal::GateFactory::create_gate<internal::SwapGateImpl>(
+        internal::vector_to_mask({target1, target2}), internal::vector_to_mask(controls));
 }
 inline Gate TwoQubitMatrix(UINT target1,
                            UINT target2,
+                           const std::vector<UINT>& controls,
                            const std::array<std::array<Complex, 4>, 4>& matrix) {
     return internal::GateFactory::create_gate<internal::TwoQubitMatrixGateImpl>(
-        target1, target2, matrix);
-}
-inline Gate Pauli(const PauliOperator& pauli) {
-    return internal::GateFactory::create_gate<internal::PauliGateImpl>(pauli);
-}
-inline Gate PauliRotation(const PauliOperator& pauli, double angle) {
-    return internal::GateFactory::create_gate<internal::PauliRotationGateImpl>(pauli, angle);
-}
-inline Gate DenseMatrix(const std::vector<UINT>& targets, const ComplexMatrix& matrix) {
+        internal::vector_to_mask({target1, target2}), internal::vector_to_mask(controls), matrix);
+}
+// まだ
+inline Gate Pauli(const std::vector<UINT>& controls, const PauliOperator& pauli) {
+    return internal::GateFactory::create_gate<internal::PauliGateImpl>(
+        internal::vector_to_mask(controls), pauli);
+}
+inline Gate PauliRotation(const std::vector<UINT>& controls,
+                          const PauliOperator& pauli,
+                          double angle) {
+    return internal::GateFactory::create_gate<internal::PauliRotationGateImpl>(
+        internal::vector_to_mask(controls), pauli, angle);
+}
+inline Gate DenseMatrix(const std::vector<UINT>& targets,
+                        const std::vector<UINT>& controls,
+                        const ComplexMatrix& matrix) {
     UINT nqubits = targets.size();
     UINT dim = 1ULL << nqubits;
     if (static_cast<UINT>(matrix.rows()) != dim || static_cast<UINT>(matrix.cols()) != dim) {
         throw std::runtime_error(
-            "gate::DenseMatrix(const std::vector<UINT>&, const ComplexMatrix&): matrix size must "
+            "gate::DenseMatrix(const std::vector<UINT>&, const ComplexMatrix&): matrix size "
+            "must "
             "be 2^{n_qubits} x 2^{n_qubits}.");
     }
     if (targets.size() == 0) return I();
     if (targets.size() == 1) {
         return OneQubitMatrix(targets[0],
+                              controls,
                               std::array{std::array{Complex(matrix(0, 0)), Complex(matrix(0, 1))},
                                          std::array{Complex(matrix(1, 0)), Complex(matrix(1, 1))}});
     }
     if (targets.size() == 2) {
         return TwoQubitMatrix(targets[0],
                               targets[1],
+                              controls,
                               std::array{
                                   std::array{Complex(matrix(0, 0)),
                                              Complex(matrix(0, 1)),
@@ -150,7 +188,8 @@ inline Gate DenseMatrix(const std::vector<UINT>& targets, const ComplexMatrix& m
                               });
     }
     throw std::runtime_error(
-        "gate::DenseMatrix(const std::vector<UINT>&, const ComplexMatrix&): DenseMatrix gate more "
+        "gate::DenseMatrix(const std::vector<UINT>&, const ComplexMatrix&): DenseMatrix gate "
+        "more "
         "than two qubits is not implemented yet.");
 }
 inline Gate Probablistic(const std::vector<double>& distribution,
diff --git a/scaluq/gate/gate_matrix.hpp b/scaluq/gate/gate_matrix.hpp
index ae8d4c0..1426507 100644
--- a/scaluq/gate/gate_matrix.hpp
+++ b/scaluq/gate/gate_matrix.hpp
@@ -11,12 +11,14 @@
 
 namespace scaluq {
 namespace internal {
-class OneQubitMatrixGateImpl : public OneQubitGateBase {
+class OneQubitMatrixGateImpl : public GateBase {
     matrix_2_2 _matrix;
 
 public:
-    OneQubitMatrixGateImpl(UINT target, const std::array<std::array<Complex, 2>, 2>& matrix)
-        : OneQubitGateBase(target) {
+    OneQubitMatrixGateImpl(UINT target_mask,
+                           UINT control_mask,
+                           const std::array<std::array<Complex, 2>, 2>& matrix)
+        : GateBase(target_mask, control_mask) {
         _matrix.val[0][0] = matrix[0][0];
         _matrix.val[0][1] = matrix[0][1];
         _matrix.val[1][0] = matrix[1][0];
@@ -29,7 +31,8 @@ public:
 
     Gate get_inverse() const override {
         return std::make_shared<OneQubitMatrixGateImpl>(
-            _target,
+            _target_mask,
+            _control_mask,
             std::array<std::array<Complex, 2>, 2>{Kokkos::conj(_matrix.val[0][0]),
                                                   Kokkos::conj(_matrix.val[1][0]),
                                                   Kokkos::conj(_matrix.val[0][1]),
@@ -43,19 +46,19 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        single_qubit_dense_matrix_gate(_target, _matrix, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        single_qubit_dense_matrix_gate(_target_mask, _control_mask, _matrix, state_vector);
     }
 };
 
-class TwoQubitMatrixGateImpl : public TwoQubitGateBase {
+class TwoQubitMatrixGateImpl : public GateBase {
     matrix_4_4 _matrix;
 
 public:
-    TwoQubitMatrixGateImpl(UINT target1,
-                           UINT target2,
+    TwoQubitMatrixGateImpl(UINT target_mask,
+                           UINT control_mask,
                            const std::array<std::array<Complex, 4>, 4>& matrix)
-        : TwoQubitGateBase(target1, target2) {
+        : GateBase(target_mask, control_mask) {
         for (UINT i : std::views::iota(0, 4)) {
             for (UINT j : std::views::iota(0, 4)) {
                 _matrix.val[i][j] = matrix[i][j];
@@ -80,7 +83,7 @@ public:
                 matrix_dag[i][j] = Kokkos::conj(_matrix.val[j][i]);
             }
         }
-        return std::make_shared<TwoQubitMatrixGateImpl>(_target1, _target2, matrix_dag);
+        return std::make_shared<TwoQubitMatrixGateImpl>(_target_mask, _control_mask, matrix_dag);
     }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat(4, 4);
@@ -94,9 +97,8 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target1);
-        check_qubit_within_bounds(state_vector, this->_target2);
-        double_qubit_dense_matrix_gate(_target1, _target2, _matrix, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        double_qubit_dense_matrix_gate(_target_mask, _control_mask, _matrix, state_vector);
     }
 };
 }  // namespace internal
diff --git a/scaluq/gate/gate_npair_qubit.hpp b/scaluq/gate/gate_npair_qubit.hpp
deleted file mode 100644
index 9495ba2..0000000
--- a/scaluq/gate/gate_npair_qubit.hpp
+++ /dev/null
@@ -1,61 +0,0 @@
-#pragma once
-
-#include <cassert>
-#include <ranges>
-
-#include "gate.hpp"
-
-namespace scaluq {
-namespace internal {
-class FusedSwapGateImpl : public GateBase {
-    UINT _qubit_index1, _qubit_index2, _block_size;
-
-public:
-    FusedSwapGateImpl(UINT qubit_index1, UINT qubit_index2, UINT block_size)
-        : _qubit_index1(qubit_index1), _qubit_index2(qubit_index2), _block_size(block_size) {
-        UINT upper_index = std::max(qubit_index1, qubit_index2);
-        UINT lower_index = std::min(qubit_index1, qubit_index2);
-        if (upper_index <= (lower_index + block_size - 1)) {
-            throw std::runtime_error(
-                "FusedSwap: upper index must be bigger than lower_index + block_size - 1");
-        }
-    };
-
-    UINT qubit_index1() const { return _qubit_index1; }
-    UINT qubit_index2() const { return _qubit_index2; }
-    UINT block_size() const { return _block_size; }
-
-    std::vector<UINT> get_target_qubit_list() const override {
-        std::vector<UINT> res(_block_size * 2);
-        std::ranges::copy(std::views::iota(_qubit_index1, _qubit_index1 + _block_size),
-                          res.begin());
-        std::ranges::copy(std::views::iota(_qubit_index2, _qubit_index2 + _block_size),
-                          res.begin() + _block_size);
-        return res;
-    }
-    std::vector<UINT> get_control_qubit_list() const override { return {}; }
-
-    Gate get_inverse() const override { return std::make_shared<FusedSwapGateImpl>(*this); }
-    std::optional<ComplexMatrix> get_matrix() const override {
-        const UINT pow2_nq = 1ULL << _block_size;
-        const UINT pow2_2nq = 1ULL << (_block_size * 2);
-        auto mat = SparseComplexMatrix(pow2_2nq, pow2_2nq);
-        mat.reserve(pow2_2nq);
-        for (UINT i = 0; i < pow2_nq; i++) {
-            for (UINT j = 0; j < pow2_nq; j++) {
-                mat.insert(i * pow2_nq + j, i + j * pow2_nq) = 1;
-            }
-        }
-        return mat;
-    }
-
-    void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_qubit_index1 + this->_block_size - 1);
-        check_qubit_within_bounds(state_vector, this->_qubit_index2 + this->_block_size - 1);
-        fusedswap_gate(this->_qubit_index1, this->_qubit_index2, this->_block_size, state_vector);
-    }
-};
-}  // namespace internal
-
-using FusedSwapGate = internal::GatePtr<internal::FusedSwapGateImpl>;
-}  // namespace scaluq
diff --git a/scaluq/gate/gate_one_control_one_target.hpp b/scaluq/gate/gate_one_control_one_target.hpp
deleted file mode 100644
index cfd1ffa..0000000
--- a/scaluq/gate/gate_one_control_one_target.hpp
+++ /dev/null
@@ -1,62 +0,0 @@
-#pragma once
-
-#include <vector>
-
-#include "gate.hpp"
-
-namespace scaluq {
-namespace internal {
-class OneControlOneTargetGateBase : public GateBase {
-protected:
-    UINT _control, _target;
-
-public:
-    OneControlOneTargetGateBase(UINT control, UINT target) : _control(control), _target(target){};
-
-    UINT control() const { return _control; }
-    UINT target() const { return _target; }
-
-    std::vector<UINT> get_target_qubit_list() const override { return {_target}; }
-    std::vector<UINT> get_control_qubit_list() const override { return {_control}; };
-};
-
-class CXGateImpl : public OneControlOneTargetGateBase {
-public:
-    CXGateImpl(UINT control, UINT target) : OneControlOneTargetGateBase(control, target) {}
-
-    Gate get_inverse() const override { return std::make_shared<CXGateImpl>(*this); }
-    std::optional<ComplexMatrix> get_matrix() const override {
-        ComplexMatrix mat(4, 4);
-        mat << 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0;
-        return mat;
-    }
-
-    void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_control);
-        check_qubit_within_bounds(state_vector, this->_target);
-        cx_gate(this->_control, this->_target, state_vector);
-    }
-};
-
-class CZGateImpl : public OneControlOneTargetGateBase {
-public:
-    CZGateImpl(UINT control, UINT target) : OneControlOneTargetGateBase(control, target) {}
-
-    Gate get_inverse() const override { return std::make_shared<CZGateImpl>(*this); }
-    std::optional<ComplexMatrix> get_matrix() const override {
-        ComplexMatrix mat(4, 4);
-        mat << 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1;
-        return mat;
-    }
-
-    void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_control);
-        check_qubit_within_bounds(state_vector, this->_target);
-        cz_gate(this->_control, this->_target, state_vector);
-    }
-};
-}  // namespace internal
-
-using CXGate = internal::GatePtr<internal::CXGateImpl>;
-using CZGate = internal::GatePtr<internal::CZGateImpl>;
-}  // namespace scaluq
diff --git a/scaluq/gate/gate_one_qubit.hpp b/scaluq/gate/gate_one_qubit.hpp
index 04b399e..83940a4 100644
--- a/scaluq/gate/gate_one_qubit.hpp
+++ b/scaluq/gate/gate_one_qubit.hpp
@@ -5,32 +5,21 @@
 
 namespace scaluq {
 namespace internal {
-class OneQubitGateBase : public GateBase {
-protected:
-    UINT _target;
-
-public:
-    OneQubitGateBase(UINT target) : _target(target){};
-
-    UINT target() const { return _target; }
-
-    std::vector<UINT> get_target_qubit_list() const override { return {_target}; }
-    std::vector<UINT> get_control_qubit_list() const override { return {}; };
-};
 
-class OneQubitRotationGateBase : public OneQubitGateBase {
+class RotationGateBase : public GateBase {
 protected:
     double _angle;
 
 public:
-    OneQubitRotationGateBase(UINT target, double angle) : OneQubitGateBase(target), _angle(angle){};
+    RotationGateBase(UINT target_mask, UINT control_mask, double angle)
+        : GateBase(target_mask, control_mask), _angle(angle) {}
 
     double angle() const { return _angle; }
 };
 
-class XGateImpl : public OneQubitGateBase {
+class XGateImpl : public GateBase {
 public:
-    XGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
     Gate get_inverse() const override { return std::make_shared<XGateImpl>(*this); }
     std::optional<ComplexMatrix> get_matrix() const override {
@@ -40,14 +29,14 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        x_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        x_gate(_target_mask, _control_mask, state_vector);
     }
 };
 
-class YGateImpl : public OneQubitGateBase {
+class YGateImpl : public GateBase {
 public:
-    YGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
     Gate get_inverse() const override { return std::make_shared<YGateImpl>(*this); }
     std::optional<ComplexMatrix> get_matrix() const override {
@@ -57,14 +46,14 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        y_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        y_gate(_target_mask, _control_mask, state_vector);
     }
 };
 
-class ZGateImpl : public OneQubitGateBase {
+class ZGateImpl : public GateBase {
 public:
-    ZGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
     Gate get_inverse() const override { return std::make_shared<ZGateImpl>(*this); }
     std::optional<ComplexMatrix> get_matrix() const override {
@@ -74,14 +63,14 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        z_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        z_gate(_target_mask, _control_mask, state_vector);
     }
 };
 
-class HGateImpl : public OneQubitGateBase {
+class HGateImpl : public GateBase {
 public:
-    HGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
     Gate get_inverse() const override { return std::make_shared<HGateImpl>(*this); }
     std::optional<ComplexMatrix> get_matrix() const override {
@@ -92,8 +81,8 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        h_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        h_gate(_target_mask, _control_mask, state_vector);
     }
 };
 
@@ -106,9 +95,9 @@ class SqrtXdagGateImpl;
 class SqrtYGateImpl;
 class SqrtYdagGateImpl;
 
-class SGateImpl : public OneQubitGateBase {
+class SGateImpl : public GateBase {
 public:
-    SGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
     Gate get_inverse() const override;
     std::optional<ComplexMatrix> get_matrix() const override {
@@ -118,16 +107,18 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        s_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        s_gate(_target_mask, _control_mask, state_vector);
     }
 };
 
-class SdagGateImpl : public OneQubitGateBase {
+class SdagGateImpl : public GateBase {
 public:
-    SdagGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
-    Gate get_inverse() const override { return std::make_shared<SGateImpl>(_target); }
+    Gate get_inverse() const override {
+        return std::make_shared<SGateImpl>(_target_mask, _control_mask);
+    }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat(2, 2);
         mat << 1, 0, 0, -1i;
@@ -135,16 +126,18 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        sdag_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        sdag_gate(_target_mask, _control_mask, state_vector);
     }
 };
 // for resolving dependency issues
-inline Gate SGateImpl::get_inverse() const { return std::make_shared<SdagGateImpl>(_target); }
+inline Gate SGateImpl::get_inverse() const {
+    return std::make_shared<SdagGateImpl>(_target_mask, _control_mask);
+}
 
-class TGateImpl : public OneQubitGateBase {
+class TGateImpl : public GateBase {
 public:
-    TGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
     Gate get_inverse() const override;
     std::optional<ComplexMatrix> get_matrix() const override {
@@ -154,16 +147,18 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        t_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        t_gate(_target_mask, _control_mask, state_vector);
     }
 };
 
-class TdagGateImpl : public OneQubitGateBase {
+class TdagGateImpl : public GateBase {
 public:
-    TdagGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
-    Gate get_inverse() const override { return std::make_shared<TGateImpl>(_target); }
+    Gate get_inverse() const override {
+        return std::make_shared<TGateImpl>(_target_mask, _control_mask);
+    }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat(2, 2);
         mat << 1, 0, 0, (1. - 1.i) / std::sqrt(2);
@@ -171,16 +166,18 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        tdag_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        tdag_gate(_target_mask, _control_mask, state_vector);
     }
 };
 // for resolving dependency issues
-inline Gate TGateImpl::get_inverse() const { return std::make_shared<TdagGateImpl>(_target); }
+inline Gate TGateImpl::get_inverse() const {
+    return std::make_shared<TdagGateImpl>(_target_mask, _control_mask);
+}
 
-class SqrtXGateImpl : public OneQubitGateBase {
+class SqrtXGateImpl : public GateBase {
 public:
-    SqrtXGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
     Gate get_inverse() const override;
     std::optional<ComplexMatrix> get_matrix() const override {
@@ -190,16 +187,18 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        sqrtx_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        sqrtx_gate(_target_mask, _control_mask, state_vector);
     }
 };
 
-class SqrtXdagGateImpl : public OneQubitGateBase {
+class SqrtXdagGateImpl : public GateBase {
 public:
-    SqrtXdagGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
-    Gate get_inverse() const override { return std::make_shared<SqrtXGateImpl>(_target); }
+    Gate get_inverse() const override {
+        return std::make_shared<SqrtXGateImpl>(_target_mask, _control_mask);
+    }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat(2, 2);
         mat << 0.5 - 0.5i, 0.5 + 0.5i, 0.5 + 0.5i, 0.5 - 0.5i;
@@ -207,18 +206,18 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        sqrtxdag_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        sqrtxdag_gate(_target_mask, _control_mask, state_vector);
     }
 };
 // for resolving dependency issues
 inline Gate SqrtXGateImpl::get_inverse() const {
-    return std::make_shared<SqrtXdagGateImpl>(_target);
+    return std::make_shared<SqrtXdagGateImpl>(_target_mask, _control_mask);
 }
 
-class SqrtYGateImpl : public OneQubitGateBase {
+class SqrtYGateImpl : public GateBase {
 public:
-    SqrtYGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
     Gate get_inverse() const override;
     std::optional<ComplexMatrix> get_matrix() const override {
@@ -228,16 +227,18 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        sqrty_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        sqrty_gate(_target_mask, _control_mask, state_vector);
     }
 };
 
-class SqrtYdagGateImpl : public OneQubitGateBase {
+class SqrtYdagGateImpl : public GateBase {
 public:
-    SqrtYdagGateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
-    Gate get_inverse() const override { return std::make_shared<SqrtYGateImpl>(_target); }
+    Gate get_inverse() const override {
+        return std::make_shared<SqrtYGateImpl>(_target_mask, _control_mask);
+    }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat(2, 2);
         mat << 0.5 - 0.5i, 0.5 - 0.5i, -0.5 + 0.5i, 0.5 - 0.5i;
@@ -245,18 +246,18 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        sqrtydag_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        sqrtydag_gate(_target_mask, _control_mask, state_vector);
     }
 };
 // for resolving dependency issues
 inline Gate SqrtYGateImpl::get_inverse() const {
-    return std::make_shared<SqrtYdagGateImpl>(_target);
+    return std::make_shared<SqrtYdagGateImpl>(_target_mask, _control_mask);
 }
 
-class P0GateImpl : public OneQubitGateBase {
+class P0GateImpl : public GateBase {
 public:
-    P0GateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
     Gate get_inverse() const override {
         throw std::runtime_error("P0::get_inverse: Projection gate doesn't have inverse gate");
@@ -268,14 +269,14 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        p0_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        p0_gate(_target_mask, _control_mask, state_vector);
     }
 };
 
-class P1GateImpl : public OneQubitGateBase {
+class P1GateImpl : public GateBase {
 public:
-    P1GateImpl(UINT target) : OneQubitGateBase(target){};
+    using GateBase::GateBase;
 
     Gate get_inverse() const override {
         throw std::runtime_error("P1::get_inverse: Projection gate doesn't have inverse gate");
@@ -287,16 +288,18 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        p1_gate(this->_target, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        p1_gate(_target_mask, _control_mask, state_vector);
     }
 };
 
-class RXGateImpl : public OneQubitRotationGateBase {
+class RXGateImpl : public RotationGateBase {
 public:
-    RXGateImpl(UINT target, double angle) : OneQubitRotationGateBase(target, angle){};
+    using RotationGateBase::RotationGateBase;
 
-    Gate get_inverse() const override { return std::make_shared<RXGateImpl>(_target, -_angle); }
+    Gate get_inverse() const override {
+        return std::make_shared<RXGateImpl>(_target_mask, _control_mask, -_angle);
+    }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat(2, 2);
         mat << std::cos(_angle / 2), -1i * std::sin(_angle / 2), -1i * std::sin(_angle / 2),
@@ -305,16 +308,18 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        rx_gate(this->_target, this->_angle, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        rx_gate(_target_mask, _control_mask, _angle, state_vector);
     }
 };
 
-class RYGateImpl : public OneQubitRotationGateBase {
+class RYGateImpl : public RotationGateBase {
 public:
-    RYGateImpl(UINT target, double angle) : OneQubitRotationGateBase(target, angle){};
+    using RotationGateBase::RotationGateBase;
 
-    Gate get_inverse() const override { return std::make_shared<RYGateImpl>(_target, -_angle); }
+    Gate get_inverse() const override {
+        return std::make_shared<RYGateImpl>(_target_mask, _control_mask, -_angle);
+    }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat(2, 2);
         mat << std::cos(_angle / 2), -std::sin(_angle / 2), std::sin(_angle / 2),
@@ -323,16 +328,18 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        ry_gate(this->_target, this->_angle, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        ry_gate(_target_mask, _control_mask, _angle, state_vector);
     }
 };
 
-class RZGateImpl : public OneQubitRotationGateBase {
+class RZGateImpl : public RotationGateBase {
 public:
-    RZGateImpl(UINT target, double angle) : OneQubitRotationGateBase(target, angle){};
+    using RotationGateBase::RotationGateBase;
 
-    Gate get_inverse() const override { return std::make_shared<RZGateImpl>(_target, -_angle); }
+    Gate get_inverse() const override {
+        return std::make_shared<RZGateImpl>(_target_mask, _control_mask, -_angle);
+    }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat(2, 2);
         mat << std::exp(-0.5i * _angle), 0, 0, std::exp(0.5i * _angle);
@@ -340,20 +347,23 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        rz_gate(this->_target, this->_angle, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        rz_gate(_target_mask, _control_mask, _angle, state_vector);
     }
 };
 
-class U1GateImpl : public OneQubitGateBase {
+class U1GateImpl : public GateBase {
     double _lambda;
 
 public:
-    U1GateImpl(UINT target, double lambda) : OneQubitGateBase(target), _lambda(lambda) {}
+    U1GateImpl(UINT target_mask, UINT control_mask, double lambda)
+        : GateBase(target_mask, control_mask), _lambda(lambda) {}
 
     double lambda() const { return _lambda; }
 
-    Gate get_inverse() const override { return std::make_shared<U1GateImpl>(_target, -_lambda); }
+    Gate get_inverse() const override {
+        return std::make_shared<U1GateImpl>(_target_mask, _control_mask, -_lambda);
+    }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat(2, 2);
         mat << 1, 0, 0, std::exp(1i * _lambda);
@@ -361,22 +371,23 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        u1_gate(this->_target, this->_lambda, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        u1_gate(_target_mask, _control_mask, _lambda, state_vector);
     }
 };
-class U2GateImpl : public OneQubitGateBase {
+class U2GateImpl : public GateBase {
     double _phi, _lambda;
 
 public:
-    U2GateImpl(UINT target, double phi, double lambda)
-        : OneQubitGateBase(target), _phi(phi), _lambda(lambda) {}
+    U2GateImpl(UINT target_mask, UINT control_mask, double phi, double lambda)
+        : GateBase(target_mask, control_mask), _phi(phi), _lambda(lambda) {}
 
     double phi() const { return _phi; }
     double lambda() const { return _lambda; }
 
     Gate get_inverse() const override {
-        return std::make_shared<U2GateImpl>(_target, -_lambda - PI(), -_phi + PI());
+        return std::make_shared<U2GateImpl>(
+            _target_mask, _control_mask, -_lambda - PI(), -_phi + PI());
     }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat(2, 2);
@@ -387,24 +398,24 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        u2_gate(this->_target, this->_phi, this->_lambda, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        u2_gate(_target_mask, _control_mask, _phi, _lambda, state_vector);
     }
 };
 
-class U3GateImpl : public OneQubitGateBase {
+class U3GateImpl : public GateBase {
     double _theta, _phi, _lambda;
 
 public:
-    U3GateImpl(UINT target, double theta, double phi, double lambda)
-        : OneQubitGateBase(target), _theta(theta), _phi(phi), _lambda(lambda) {}
+    U3GateImpl(UINT target_mask, UINT control_mask, double theta, double phi, double lambda)
+        : GateBase(target_mask, control_mask), _theta(theta), _phi(phi), _lambda(lambda) {}
 
     double theta() const { return _theta; }
     double phi() const { return _phi; }
     double lambda() const { return _lambda; }
 
     Gate get_inverse() const override {
-        return std::make_shared<U3GateImpl>(_target, -_theta, -_lambda, -_phi);
+        return std::make_shared<U3GateImpl>(_target_mask, _control_mask, -_theta, -_lambda, -_phi);
     }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat(2, 2);
@@ -415,8 +426,8 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        u3_gate(this->_target, this->_theta, this->_phi, this->_lambda, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        u3_gate(_target_mask, _control_mask, _theta, _phi, _lambda, state_vector);
     }
 };
 
diff --git a/scaluq/gate/gate_pauli.hpp b/scaluq/gate/gate_pauli.hpp
index dde9e3e..d03be5f 100644
--- a/scaluq/gate/gate_pauli.hpp
+++ b/scaluq/gate/gate_pauli.hpp
@@ -12,21 +12,20 @@ class PauliGateImpl : public GateBase {
     const PauliOperator _pauli;
 
 public:
-    PauliGateImpl(const PauliOperator& pauli) : _pauli(pauli) {}
+    PauliGateImpl(UINT control_mask, const PauliOperator& pauli)
+        : GateBase(vector_to_mask(_pauli.get_target_qubit_list()), control_mask), _pauli(pauli) {}
 
-    std::vector<UINT> get_target_qubit_list() const override {
-        return _pauli.get_target_qubit_list();
-    }
     std::vector<UINT> get_pauli_id_list() const { return _pauli.get_pauli_id_list(); }
-    std::vector<UINT> get_control_qubit_list() const override { return {}; }
 
-    Gate get_inverse() const override { return std::make_shared<PauliGateImpl>(this->_pauli); }
+    Gate get_inverse() const override {
+        return std::make_shared<PauliGateImpl>(_control_mask, _pauli);
+    }
     std::optional<ComplexMatrix> get_matrix() const override {
         return get_pauli_matrix(this->_pauli);
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        pauli_gate(this->_pauli, state_vector);
+        pauli_gate(_control_mask, _pauli, state_vector);
     }
 };
 
@@ -35,17 +34,13 @@ class PauliRotationGateImpl : public GateBase {
     const double _angle;
 
 public:
-    PauliRotationGateImpl(const PauliOperator& pauli, double angle)
-        : _pauli(pauli), _angle(angle) {}
-
-    std::vector<UINT> get_target_qubit_list() const override {
-        return _pauli.get_target_qubit_list();
-    }
-    std::vector<UINT> get_pauli_id_list() const { return _pauli.get_pauli_id_list(); }
-    std::vector<UINT> get_control_qubit_list() const override { return {}; }
+    PauliRotationGateImpl(UINT control_mask, const PauliOperator& pauli, double angle)
+        : GateBase(vector_to_mask(_pauli.get_target_qubit_list()), control_mask),
+          _pauli(pauli),
+          _angle(angle) {}
 
     Gate get_inverse() const override {
-        return std::make_shared<PauliRotationGateImpl>(this->_pauli, -(this->_angle));
+        return std::make_shared<PauliRotationGateImpl>(_control_mask, _pauli, -_angle);
     }
     std::optional<ComplexMatrix> get_matrix() const override {
         ComplexMatrix mat = get_pauli_matrix(this->_pauli).value();
@@ -55,7 +50,7 @@ public:
         return mat;
     }
     void update_quantum_state(StateVector& state_vector) const override {
-        pauli_rotation_gate(this->_pauli, this->_angle, state_vector);
+        pauli_rotation_gate(_control_mask, _pauli, _angle, state_vector);
     }
 };
 }  // namespace internal
diff --git a/scaluq/gate/gate_probablistic.hpp b/scaluq/gate/gate_probablistic.hpp
index c98758a..34eb31d 100644
--- a/scaluq/gate/gate_probablistic.hpp
+++ b/scaluq/gate/gate_probablistic.hpp
@@ -13,7 +13,19 @@ class ProbablisticGateImpl : public GateBase {
 public:
     ProbablisticGateImpl(const std::vector<double>& distribution,
                          const std::vector<Gate>& gate_list)
-        : _distribution(distribution), _gate_list(gate_list) {
+        : GateBase(  // make OR(target mask) and OR(control mask) at first
+              [this] {
+                  UINT mask_sum = 0;
+                  for (const auto& gate : _gate_list) mask_sum |= gate->get_target_qubit_mask();
+                  return mask_sum;
+              }(),
+              [this] {
+                  UINT mask_sum = 0;
+                  for (const auto& gate : _gate_list) mask_sum |= gate->get_control_qubit_mask();
+                  return mask_sum;
+              }()),
+          _distribution(distribution),
+          _gate_list(gate_list) {
         UINT n = distribution.size();
         if (n == 0) {
             throw std::runtime_error("At least one gate is required.");
@@ -31,31 +43,6 @@ public:
     const std::vector<Gate>& gate_list() { return _gate_list; }
     const std::vector<double>& distribution() { return _distribution; }
 
-    std::vector<UINT> get_target_qubit_list() const override {
-        std::vector<UINT> ret;
-        for (const auto& gate : _gate_list) {
-            std::vector<UINT> targets = gate->get_target_qubit_list();
-            ret.reserve(ret.size() + targets.size());
-            std::ranges::copy(targets, std::back_inserter(ret));
-        }
-        std::ranges::sort(ret);
-        auto result = std::ranges::unique(ret);
-        ret.erase(result.begin(), result.end());
-        return ret;
-    }
-    std::vector<UINT> get_control_qubit_list() const override {
-        std::vector<UINT> ret;
-        for (const auto& gate : _gate_list) {
-            std::vector<UINT> controls = gate->get_control_qubit_list();
-            ret.reserve(ret.size() + controls.size());
-            std::ranges::copy(controls, std::back_inserter(ret));
-        }
-        std::ranges::sort(ret);
-        auto result = std::ranges::unique(ret);
-        ret.erase(result.begin(), result.end());
-        return ret;
-    }
-
     Gate get_inverse() const override {
         std::vector<Gate> inv_gate_list;
         inv_gate_list.reserve(_gate_list.size());
diff --git a/scaluq/gate/gate_two_qubit.hpp b/scaluq/gate/gate_two_qubit.hpp
index 4e5393d..390e052 100644
--- a/scaluq/gate/gate_two_qubit.hpp
+++ b/scaluq/gate/gate_two_qubit.hpp
@@ -6,23 +6,10 @@
 
 namespace scaluq {
 namespace internal {
-class TwoQubitGateBase : public GateBase {
-protected:
-    UINT _target1, _target2;
 
+class SwapGateImpl : public GateBase {
 public:
-    TwoQubitGateBase(UINT target1, UINT target2) : _target1(target1), _target2(target2){};
-
-    UINT target1() const { return _target1; }
-    UINT target2() const { return _target2; }
-
-    std::vector<UINT> get_target_qubit_list() const override { return {_target1, _target2}; }
-    std::vector<UINT> get_control_qubit_list() const override { return {}; }
-};
-
-class SwapGateImpl : public TwoQubitGateBase {
-public:
-    SwapGateImpl(UINT target1, UINT target2) : TwoQubitGateBase(target1, target2) {}
+    using GateBase::GateBase;
 
     Gate get_inverse() const override { return std::make_shared<SwapGateImpl>(*this); }
     std::optional<ComplexMatrix> get_matrix() const override {
@@ -32,9 +19,8 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        check_qubit_within_bounds(state_vector, this->_target1);
-        check_qubit_within_bounds(state_vector, this->_target2);
-        swap_gate(this->_target1, this->_target2, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        swap_gate(_target_mask, _control_mask, state_vector);
     }
 };
 }  // namespace internal
diff --git a/scaluq/gate/gate_zero_qubit.hpp b/scaluq/gate/gate_zero_qubit.hpp
index d67a001..b44a6c5 100644
--- a/scaluq/gate/gate_zero_qubit.hpp
+++ b/scaluq/gate/gate_zero_qubit.hpp
@@ -4,42 +4,41 @@
 
 namespace scaluq {
 namespace internal {
-class ZeroQubitGateBase : public GateBase {
-public:
-    ZeroQubitGateBase(){};
-
-    std::vector<UINT> get_target_qubit_list() const override { return {}; }
-    std::vector<UINT> get_control_qubit_list() const override { return {}; };
-};
 
-class IGateImpl : public ZeroQubitGateBase {
+class IGateImpl : public GateBase {
 public:
-    IGateImpl() : ZeroQubitGateBase(){};
+    IGateImpl() : GateBase(0, 0) {}
 
     Gate get_inverse() const override { return std::make_shared<IGateImpl>(*this); }
     std::optional<ComplexMatrix> get_matrix() const override {
         return ComplexMatrix::Identity(1, 1);
     }
 
-    void update_quantum_state(StateVector& state_vector) const override { i_gate(state_vector); }
+    void update_quantum_state(StateVector& state_vector) const override {
+        i_gate(_target_mask, _control_mask, state_vector);
+    }
 };
 
-class GlobalPhaseGateImpl : public ZeroQubitGateBase {
+class GlobalPhaseGateImpl : public GateBase {
 protected:
     double _phase;
 
 public:
-    GlobalPhaseGateImpl(double phase) : ZeroQubitGateBase(), _phase(phase){};
+    GlobalPhaseGateImpl(UINT control_mask, double phase)
+        : GateBase(0, control_mask), _phase(phase){};
 
     [[nodiscard]] double phase() const { return _phase; }
 
-    Gate get_inverse() const override { return std::make_shared<GlobalPhaseGateImpl>(-_phase); }
+    Gate get_inverse() const override {
+        return std::make_shared<GlobalPhaseGateImpl>(_control_mask, -_phase);
+    }
     std::optional<ComplexMatrix> get_matrix() const override {
         return ComplexMatrix::Identity(1, 1) * std::exp(std::complex<double>(0, _phase));
     }
 
     void update_quantum_state(StateVector& state_vector) const override {
-        global_phase_gate(_phase, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        global_phase_gate(_target_mask, _control_mask, _phase, state_vector);
     }
 };
 }  // namespace internal
diff --git a/scaluq/gate/param_gate.hpp b/scaluq/gate/param_gate.hpp
index 34c8a53..ec647e0 100644
--- a/scaluq/gate/param_gate.hpp
+++ b/scaluq/gate/param_gate.hpp
@@ -39,17 +39,32 @@ constexpr ParamGateType get_param_gate_type() {
 namespace internal {
 class ParamGateBase {
 protected:
+    UINT _target_mask, _control_mask;
     double _pcoef;
+    void check_qubit_mask_within_bounds(StateVector& state_vector) const {
+        UINT full_mask = (1ULL << state_vector.n_qubits()) - 1;
+        if ((_target_mask | _control_mask) > full_mask) [[unlikely]] {
+            throw std::runtime_error(
+                "Error: ParamGate::update_quantum_state(StateVector& state): "
+                "Target/Control qubit exceeds the number of qubits in the system.");
+        }
+    }
 
 public:
+    ParamGateBase(UINT target_mask, UINT control_mask, double pcoef = 1.)
+        : _target_mask(target_mask), _control_mask(control_mask), _pcoef(pcoef) {}
     virtual ~ParamGateBase() = default;
 
-    ParamGateBase(double pcoef = 1.) : _pcoef(pcoef) {}
-
     [[nodiscard]] double pcoef() { return _pcoef; }
 
-    [[nodiscard]] virtual std::vector<UINT> get_target_qubit_list() const = 0;
-    [[nodiscard]] virtual std::vector<UINT> get_control_qubit_list() const = 0;
+    [[nodiscard]] std::vector<UINT> get_target_qubit_list() const {
+        return mask_to_vector(_target_mask);
+    }
+    [[nodiscard]] std::vector<UINT> get_control_qubit_list() const {
+        return mask_to_vector(_control_mask);
+    }
+    [[nodiscard]] UINT get_target_qubit_mask() const { return _target_mask; }
+    [[nodiscard]] UINT get_control_qubit_mask() const { return _control_mask; }
 
     [[nodiscard]] virtual ParamGate get_inverse() const = 0;
     [[nodiscard]] virtual std::optional<ComplexMatrix> get_matrix(double param) const = 0;
diff --git a/scaluq/gate/param_gate_factory.hpp b/scaluq/gate/param_gate_factory.hpp
index cdac6b6..0754f31 100644
--- a/scaluq/gate/param_gate_factory.hpp
+++ b/scaluq/gate/param_gate_factory.hpp
@@ -15,17 +15,24 @@ public:
 };
 }  // namespace internal
 namespace gate {
-inline ParamGate PRX(UINT target, double pcoef = 1.) {
-    return internal::ParamGateFactory::create_gate<internal::PRXGateImpl>(target, pcoef);
+inline ParamGate PRX(UINT target, const std::vector<UINT>& controls, double pcoef = 1.) {
+    return internal::ParamGateFactory::create_gate<internal::PRXGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls), pcoef);
 }
-inline ParamGate PRY(UINT target, double pcoef = 1.) {
-    return internal::ParamGateFactory::create_gate<internal::PRYGateImpl>(target, pcoef);
+inline ParamGate PRY(UINT target, const std::vector<UINT>& controls, double pcoef = 1.) {
+    return internal::ParamGateFactory::create_gate<internal::PRYGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls), pcoef);
 }
-inline ParamGate PRZ(UINT target, double pcoef = 1.) {
-    return internal::ParamGateFactory::create_gate<internal::PRZGateImpl>(target, pcoef);
+inline ParamGate PRZ(UINT target, const std::vector<UINT>& controls, double pcoef = 1.) {
+    return internal::ParamGateFactory::create_gate<internal::PRZGateImpl>(
+        internal::vector_to_mask({target}), internal::vector_to_mask(controls), pcoef);
 }
-inline ParamGate PPauliRotation(const PauliOperator& pauli, double pcoef = 1.) {
-    return internal::ParamGateFactory::create_gate<internal::PPauliRotationGateImpl>(pauli, pcoef);
+// まだ
+inline ParamGate PPauliRotation(const std::vector<UINT>& controls,
+                                const PauliOperator& pauli,
+                                double pcoef = 1.) {
+    return internal::ParamGateFactory::create_gate<internal::PPauliRotationGateImpl>(
+        internal::vector_to_mask(controls), pauli, pcoef);
 }
 inline ParamGate PProbablistic(const std::vector<double>& distribution,
                                const std::vector<std::variant<Gate, ParamGate>>& gate_list) {
diff --git a/scaluq/gate/param_gate_one_qubit.hpp b/scaluq/gate/param_gate_one_qubit.hpp
index c745913..c0dd59e 100644
--- a/scaluq/gate/param_gate_one_qubit.hpp
+++ b/scaluq/gate/param_gate_one_qubit.hpp
@@ -7,25 +7,13 @@
 namespace scaluq {
 
 namespace internal {
-class POneQubitGateBase : public ParamGateBase {
-protected:
-    UINT _target;
 
+class PRXGateImpl : public ParamGateBase {
 public:
-    POneQubitGateBase(UINT target, double pcoef = 1.) : ParamGateBase(pcoef), _target(target){};
-
-    UINT target() const { return _target; }
-
-    std::vector<UINT> get_target_qubit_list() const override { return {_target}; }
-    std::vector<UINT> get_control_qubit_list() const override { return {}; };
-};
-
-class PRXGateImpl : public POneQubitGateBase {
-public:
-    PRXGateImpl(UINT target, double pcoef = 1.) : POneQubitGateBase(target, pcoef){};
+    using ParamGateBase::ParamGateBase;
 
     ParamGate get_inverse() const override {
-        return std::make_shared<PRXGateImpl>(_target, -_pcoef);
+        return std::make_shared<PRXGateImpl>(_target_mask, _control_mask, -_pcoef);
     }
     std::optional<ComplexMatrix> get_matrix(double param) const override {
         double angle = _pcoef * param;
@@ -36,17 +24,17 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector, double param) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        rx_gate(_target, _pcoef * param, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        rx_gate(_target_mask, _control_mask, _pcoef * param, state_vector);
     }
 };
 
-class PRYGateImpl : public POneQubitGateBase {
+class PRYGateImpl : public ParamGateBase {
 public:
-    PRYGateImpl(UINT target, double pcoef) : POneQubitGateBase(target, pcoef){};
+    using ParamGateBase::ParamGateBase;
 
     ParamGate get_inverse() const override {
-        return std::make_shared<PRYGateImpl>(_target, -_pcoef);
+        return std::make_shared<PRYGateImpl>(_target_mask, _control_mask, -_pcoef);
     }
     std::optional<ComplexMatrix> get_matrix(double param) const override {
         double angle = _pcoef * param;
@@ -56,17 +44,17 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector, double param) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        ry_gate(_target, _pcoef * param, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        ry_gate(_target_mask, _control_mask, _pcoef * param, state_vector);
     }
 };
 
-class PRZGateImpl : public POneQubitGateBase {
+class PRZGateImpl : public ParamGateBase {
 public:
-    PRZGateImpl(UINT target, double pcoef) : POneQubitGateBase(target, pcoef){};
+    using ParamGateBase::ParamGateBase;
 
     ParamGate get_inverse() const override {
-        return std::make_shared<PRZGateImpl>(_target, -_pcoef);
+        return std::make_shared<PRZGateImpl>(_target_mask, _control_mask, -_pcoef);
     }
     std::optional<ComplexMatrix> get_matrix(double param) const override {
         double angle = param * _pcoef;
@@ -76,8 +64,8 @@ public:
     }
 
     void update_quantum_state(StateVector& state_vector, double param) const override {
-        check_qubit_within_bounds(state_vector, this->_target);
-        rz_gate(this->_target, _pcoef * param, state_vector);
+        check_qubit_mask_within_bounds(state_vector);
+        rz_gate(_target_mask, _control_mask, _pcoef * param, state_vector);
     }
 };
 
diff --git a/scaluq/gate/param_gate_pauli.hpp b/scaluq/gate/param_gate_pauli.hpp
index 35d6d37..0509713 100644
--- a/scaluq/gate/param_gate_pauli.hpp
+++ b/scaluq/gate/param_gate_pauli.hpp
@@ -12,17 +12,14 @@ class PPauliRotationGateImpl : public ParamGateBase {
     const PauliOperator _pauli;
 
 public:
-    PPauliRotationGateImpl(const PauliOperator& pauli, double pcoef = 1.)
-        : ParamGateBase(pcoef), _pauli(pauli) {}
+    PPauliRotationGateImpl(UINT control_mask, const PauliOperator& pauli, double pcoef = 1.)
+        : ParamGateBase(vector_to_mask(_pauli.get_target_qubit_list()), control_mask, pcoef),
+          _pauli(pauli) {}
 
-    std::vector<UINT> get_target_qubit_list() const override {
-        return _pauli.get_target_qubit_list();
-    }
     std::vector<UINT> get_pauli_id_list() const { return _pauli.get_pauli_id_list(); }
-    std::vector<UINT> get_control_qubit_list() const override { return {}; }
 
     ParamGate get_inverse() const override {
-        return std::make_shared<PPauliRotationGateImpl>(_pauli, -_pcoef);
+        return std::make_shared<PPauliRotationGateImpl>(_control_mask, _pauli, -_pcoef);
     }
     std::optional<ComplexMatrix> get_matrix(double param) const override {
         double angle = _pcoef * param;
@@ -33,7 +30,7 @@ public:
         return mat;
     }
     void update_quantum_state(StateVector& state_vector, double param) const override {
-        pauli_rotation_gate(_pauli, _pcoef * param, state_vector);
+        pauli_rotation_gate(_control_mask, _pauli, _pcoef * param, state_vector);
     }
 };
 }  // namespace internal
diff --git a/scaluq/gate/param_gate_probablistic.hpp b/scaluq/gate/param_gate_probablistic.hpp
index 89c50ed..29b56aa 100644
--- a/scaluq/gate/param_gate_probablistic.hpp
+++ b/scaluq/gate/param_gate_probablistic.hpp
@@ -17,7 +17,25 @@ class PProbablisticGateImpl : public ParamGateBase {
 public:
     PProbablisticGateImpl(const std::vector<double>& distribution,
                           const std::vector<std::variant<Gate, ParamGate>>& gate_list)
-        : _distribution(distribution), _gate_list(gate_list) {
+        : ParamGateBase(  // make OR(target mask) and OR(control mask) at first
+              [this] {
+                  UINT mask_sum = 0;
+                  for (const auto& gate : _gate_list) {
+                      mask_sum |= std::visit(
+                          [](const auto& g) { return g->get_target_qubit_mask(); }, gate);
+                  }
+                  return mask_sum;
+              }(),
+              [this] {
+                  UINT mask_sum = 0;
+                  for (const auto& gate : _gate_list) {
+                      mask_sum |= std::visit(
+                          [](const auto& g) { return g->get_control_qubit_mask(); }, gate);
+                  }
+                  return mask_sum;
+              }()),
+          _distribution(distribution),
+          _gate_list(gate_list) {
         UINT n = distribution.size();
         if (n == 0) {
             throw std::runtime_error("At least one gate is required.");
@@ -35,33 +53,6 @@ public:
     const std::vector<std::variant<Gate, ParamGate>>& gate_list() { return _gate_list; }
     const std::vector<double>& distribution() { return _distribution; }
 
-    std::vector<UINT> get_target_qubit_list() const override {
-        std::vector<UINT> ret;
-        for (const auto& gate : _gate_list) {
-            std::vector<UINT> targets =
-                std::visit([](const auto& g) { return g->get_target_qubit_list(); }, gate);
-            ret.reserve(ret.size() + targets.size());
-            std::ranges::copy(targets, std::back_inserter(ret));
-        }
-        std::ranges::sort(ret);
-        auto result = std::ranges::unique(ret);
-        ret.erase(result.begin(), result.end());
-        return ret;
-    }
-    std::vector<UINT> get_control_qubit_list() const override {
-        std::vector<UINT> ret;
-        for (const auto& gate : _gate_list) {
-            std::vector<UINT> controls =
-                std::visit([](const auto& g) { return g->get_control_qubit_list(); }, gate);
-            ret.reserve(ret.size() + controls.size());
-            std::ranges::copy(controls, std::back_inserter(ret));
-        }
-        std::ranges::sort(ret);
-        auto result = std::ranges::unique(ret);
-        ret.erase(result.begin(), result.end());
-        return ret;
-    }
-
     ParamGate get_inverse() const override {
         std::vector<EitherGate> inv_gate_list;
         inv_gate_list.reserve(_gate_list.size());
diff --git a/scaluq/gate/update_ops.hpp b/scaluq/gate/update_ops.hpp
index 8140f09..f5954f7 100644
--- a/scaluq/gate/update_ops.hpp
+++ b/scaluq/gate/update_ops.hpp
@@ -7,82 +7,78 @@
 
 namespace scaluq {
 namespace internal {
-inline void check_qubit_within_bounds(const StateVector& state, UINT op_qubit) {
-    if (op_qubit >= state.n_qubits()) [[unlikely]] {
-        throw std::runtime_error(
-            "Error: Gate::update_quantum_state(StateVector& state): "
-            "Target/Control qubit exceeds the number of qubits in the system.");
-    }
-}
+void i_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void i_gate(StateVector& state);
+void global_phase_gate(UINT target_mask, UINT control_mask, double angle, StateVector& state);
 
-void global_phase_gate(double angle, StateVector& state);
+void x_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void x_gate(UINT target_qubit_index, StateVector& state);
+void y_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void y_gate(UINT target_qubit_index, StateVector& state);
+void z_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void z_gate(UINT target_qubit_index, StateVector& state);
+void h_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void h_gate(UINT target_qubit_index, StateVector& state);
+void s_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void s_gate(UINT target_qubit_index, StateVector& state);
+void sdag_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void sdag_gate(UINT target_qubit_index, StateVector& state);
+void t_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void t_gate(UINT target_qubit_index, StateVector& state);
+void tdag_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void tdag_gate(UINT target_qubit_index, StateVector& state);
+void sqrtx_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void sqrtx_gate(UINT target_qubit_index, StateVector& state);
+void sqrtxdag_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void sqrtxdag_gate(UINT target_qubit_index, StateVector& state);
+void sqrty_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void sqrty_gate(UINT target_qubit_index, StateVector& state);
+void sqrtydag_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void sqrtydag_gate(UINT target_qubit_index, StateVector& state);
+void p0_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void p0_gate(UINT target_qubit_index, StateVector& state);
+void p1_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void p1_gate(UINT target_qubit_index, StateVector& state);
+void rx_gate(UINT target_mask, UINT control_mask, double angle, StateVector& state);
 
-void rx_gate(UINT target_qubit_index, double angle, StateVector& state);
+void ry_gate(UINT target_mask, UINT control_mask, double angle, StateVector& state);
 
-void ry_gate(UINT target_qubit_index, double angle, StateVector& state);
+void rz_gate(UINT target_mask, UINT control_mask, double angle, StateVector& state);
 
-void rz_gate(UINT target_qubit_index, double angle, StateVector& state);
+void cx_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void cx_gate(UINT control_qubit_index, UINT target_qubit_index, StateVector& state);
-
-void cz_gate(UINT control_qubit_index, UINT target_qubit_index, StateVector& state);
+void cz_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
 matrix_2_2 get_IBMQ_matrix(double _theta, double _phi, double _lambda);
 
-void single_qubit_dense_matrix_gate(UINT target_qubit_index,
+void single_qubit_dense_matrix_gate(UINT target_mask,
+                                    UINT control_mask,
                                     const matrix_2_2& matrix,
                                     StateVector& state);
 
-void double_qubit_dense_matrix_gate(UINT target0,
-                                    UINT target1,
+void double_qubit_dense_matrix_gate(UINT target_mask,
+                                    UINT control_mask,
                                     const matrix_4_4& matrix,
                                     StateVector& state);
 
-void u1_gate(UINT target_qubit_index, double lambda, StateVector& state);
-
-void u2_gate(UINT target_qubit_index, double phi, double lambda, StateVector& state);
+void u1_gate(UINT target_mask, UINT control_mask, double lambda, StateVector& state);
 
-void u3_gate(UINT target_qubit_index, double theta, double phi, double lambda, StateVector& state);
+void u2_gate(UINT target_mask, UINT control_mask, double phi, double lambda, StateVector& state);
 
-void swap_gate(UINT target1, UINT target2, StateVector& state);
+void u3_gate(UINT target_mask,
+             UINT control_mask,
+             double theta,
+             double phi,
+             double lambda,
+             StateVector& state);
 
-void fusedswap_gate(UINT target_qubit_index_0,
-                    UINT target_qubit_index_1,
-                    UINT block_size,
-                    StateVector& state);
+void swap_gate(UINT target_mask, UINT control_mask, StateVector& state);
 
-void pauli_gate(const PauliOperator& pauli, StateVector& state);
+void pauli_gate(UINT control_mask, const PauliOperator& pauli, StateVector& state);
 
-void pauli_rotation_gate(const PauliOperator& pauli, double angle, StateVector& state);
+void pauli_rotation_gate(UINT control_mask,
+                         const PauliOperator& pauli,
+                         double angle,
+                         StateVector& state);
 }  // namespace internal
 }  // namespace scaluq
diff --git a/scaluq/gate/update_ops_dense_matrix.cpp b/scaluq/gate/update_ops_dense_matrix.cpp
index e0b02f8..3a85a80 100644
--- a/scaluq/gate/update_ops_dense_matrix.cpp
+++ b/scaluq/gate/update_ops_dense_matrix.cpp
@@ -6,13 +6,15 @@
 
 namespace scaluq {
 namespace internal {
-void single_qubit_dense_matrix_gate(UINT target_qubit_index,
+void single_qubit_dense_matrix_gate(UINT target_mask,
+                                    UINT control_mask,
                                     const matrix_2_2& matrix,
                                     StateVector& state) {
     Kokkos::parallel_for(
-        state.dim() >> 1, KOKKOS_LAMBDA(const UINT it) {
-            UINT basis_0 = internal::insert_zero_to_basis_index(it, target_qubit_index);
-            UINT basis_1 = basis_0 | (1ULL << target_qubit_index);
+        state.dim() >> std::popcount(target_mask | control_mask), KOKKOS_LAMBDA(UINT it) {
+            UINT basis_0 =
+                insert_zero_at_mask_positions(it, control_mask | target_mask) | control_mask;
+            UINT basis_1 = basis_0 | target_mask;
             Complex val0 = state._raw[basis_0];
             Complex val1 = state._raw[basis_1];
             Complex res0 = matrix.val[0][0] * val0 + matrix.val[0][1] * val1;
@@ -23,16 +25,19 @@ void single_qubit_dense_matrix_gate(UINT target_qubit_index,
     Kokkos::fence();
 }
 
-void double_qubit_dense_matrix_gate(UINT target0,
-                                    UINT target1,
+void double_qubit_dense_matrix_gate(UINT target_mask,
+                                    UINT control_mask,
                                     const matrix_4_4& matrix,
                                     StateVector& state) {
+    UINT lower_target_mask = -target_mask & target_mask;
+    UINT upper_target_mask = target_mask ^ lower_target_mask;
     Kokkos::parallel_for(
-        state.dim() >> 2, KOKKOS_LAMBDA(const UINT it) {
-            UINT basis_0 = internal::insert_zero_to_basis_index(it, target0, target1);
-            UINT basis_1 = basis_0 | (1ULL << target0);
-            UINT basis_2 = basis_0 | (1ULL << target1);
-            UINT basis_3 = basis_1 | (1ULL << target1);
+        state.dim() >> std::popcount(target_mask | control_mask), KOKKOS_LAMBDA(const UINT it) {
+            UINT basis_0 =
+                insert_zero_at_mask_positions(it, target_mask | control_mask) | control_mask;
+            UINT basis_1 = basis_0 | lower_target_mask;
+            UINT basis_2 = basis_0 | upper_target_mask;
+            UINT basis_3 = basis_1 | target_mask;
             Complex val0 = state._raw[basis_0];
             Complex val1 = state._raw[basis_1];
             Complex val2 = state._raw[basis_2];
diff --git a/scaluq/gate/update_ops_npair_qubit.cpp b/scaluq/gate/update_ops_npair_qubit.cpp
deleted file mode 100644
index 1d72f0e..0000000
--- a/scaluq/gate/update_ops_npair_qubit.cpp
+++ /dev/null
@@ -1,37 +0,0 @@
-#include <Kokkos_Core.hpp>
-#include <Kokkos_StdAlgorithms.hpp>
-#include <cassert>
-
-#include "../types.hpp"
-#include "update_ops.hpp"
-
-namespace scaluq {
-namespace internal {
-void fusedswap_gate(UINT target_qubit_index_0,
-                    UINT target_qubit_index_1,
-                    UINT block_size,
-                    StateVector& state) {
-    UINT n_qubits = state.n_qubits();
-    auto [lower_index, upper_index] = Kokkos::minmax(target_qubit_index_0, target_qubit_index_1);
-    if (n_qubits <= (upper_index + block_size - 1)) {
-        throw std::runtime_error(
-            "FusedSwap: num of qubits must be bigger than upper_index + block_size - 1");
-    }
-    const UINT mask_block = (1 << block_size) - 1;
-    const UINT kblk_mask = mask_block << upper_index;
-    const UINT jblk_mask = mask_block << lower_index;
-    const UINT else_mask = (1 << n_qubits) - 1 - kblk_mask - jblk_mask;
-
-    Kokkos::parallel_for(
-        state.dim(), KOKKOS_LAMBDA(UINT i) {
-            const UINT kblk = (i & kblk_mask) >> upper_index;
-            const UINT jblk = (i & jblk_mask) >> lower_index;
-            if (jblk > kblk) {
-                const UINT j = (i & else_mask) | jblk << upper_index | kblk << lower_index;
-                Kokkos::Experimental::swap(state._raw[i], state._raw[j]);
-            }
-        });
-    Kokkos::fence();
-}
-}  // namespace internal
-}  // namespace scaluq
diff --git a/scaluq/gate/update_ops_one_control_one_target.cpp b/scaluq/gate/update_ops_one_control_one_target.cpp
deleted file mode 100644
index 9d07f30..0000000
--- a/scaluq/gate/update_ops_one_control_one_target.cpp
+++ /dev/null
@@ -1,34 +0,0 @@
-#include <Kokkos_Core.hpp>
-#include <Kokkos_StdAlgorithms.hpp>
-
-#include "../types.hpp"
-#include "constant.hpp"
-#include "update_ops.hpp"
-#include "util/utility.hpp"
-
-namespace scaluq {
-namespace internal {
-void cx_gate(UINT control_qubit_index, UINT target_qubit_index, StateVector& state) {
-    Kokkos::parallel_for(
-        state.dim() >> 2, KOKKOS_LAMBDA(UINT it) {
-            UINT i =
-                internal::insert_zero_to_basis_index(it, target_qubit_index, control_qubit_index);
-            i |= 1ULL << control_qubit_index;
-            Kokkos::Experimental::swap(state._raw[i], state._raw[i | (1ULL << target_qubit_index)]);
-        });
-    Kokkos::fence();
-}
-
-void cz_gate(UINT control_qubit_index, UINT target_qubit_index, StateVector& state) {
-    Kokkos::parallel_for(
-        state.dim() >> 2, KOKKOS_LAMBDA(UINT it) {
-            UINT i =
-                internal::insert_zero_to_basis_index(it, target_qubit_index, control_qubit_index);
-            i |= 1ULL << control_qubit_index;
-            i |= 1ULL << target_qubit_index;
-            state._raw[i] *= -1;
-        });
-    Kokkos::fence();
-}
-}  // namespace internal
-}  // namespace scaluq
diff --git a/scaluq/gate/update_ops_one_qubit.cpp b/scaluq/gate/update_ops_one_qubit.cpp
index 32bc365..d20dfba 100644
--- a/scaluq/gate/update_ops_one_qubit.cpp
+++ b/scaluq/gate/update_ops_one_qubit.cpp
@@ -8,124 +8,129 @@
 
 namespace scaluq {
 namespace internal {
-void x_gate(UINT target_qubit_index, StateVector& state) {
+void x_gate(UINT target_mask, UINT control_mask, StateVector& state) {
     Kokkos::parallel_for(
-        state.dim() >> 1, KOKKOS_LAMBDA(UINT it) {
-            UINT i = internal::insert_zero_to_basis_index(it, target_qubit_index);
-            Kokkos::Experimental::swap(state._raw[i], state._raw[i | (1ULL << target_qubit_index)]);
+        state.dim() >> std::popcount(target_mask | control_mask), KOKKOS_LAMBDA(UINT it) {
+            UINT i = insert_zero_at_mask_positions(it, control_mask | target_mask) | control_mask;
+            Kokkos::Experimental::swap(state._raw[i], state._raw[i | target_mask]);
         });
     Kokkos::fence();
 }
-
-void y_gate(UINT target_qubit_index, StateVector& state) {
+void y_gate(UINT target_mask, UINT control_mask, StateVector& state) {
     Kokkos::parallel_for(
-        state.dim() >> 1, KOKKOS_LAMBDA(UINT it) {
-            UINT i = internal::insert_zero_to_basis_index(it, target_qubit_index);
+        state.dim() >> std::popcount(target_mask | control_mask), KOKKOS_LAMBDA(UINT it) {
+            UINT i = insert_zero_at_mask_positions(it, control_mask | target_mask) | control_mask;
             state._raw[i] *= Complex(0, 1);
-            state._raw[i | (1ULL << target_qubit_index)] *= Complex(0, -1);
-            Kokkos::Experimental::swap(state._raw[i], state._raw[i | (1ULL << target_qubit_index)]);
+            state._raw[i | target_mask] *= Complex(0, -1);
+            Kokkos::Experimental::swap(state._raw[i], state._raw[i | target_mask]);
         });
     Kokkos::fence();
 }
 
-void z_gate(UINT target_qubit_index, StateVector& state) {
+void z_gate(UINT target_mask, UINT control_mask, StateVector& state) {
     Kokkos::parallel_for(
-        state.dim() >> 1, KOKKOS_LAMBDA(UINT it) {
-            UINT i = internal::insert_zero_to_basis_index(it, target_qubit_index);
-            state._raw[i | (1ULL << target_qubit_index)] *= Complex(-1, 0);
+        state.dim() >> std::popcount(target_mask | control_mask), KOKKOS_LAMBDA(UINT it) {
+            UINT i = insert_zero_at_mask_positions(it, control_mask | target_mask) | control_mask;
+            state._raw[i | target_mask] *= Complex(-1, 0);
         });
     Kokkos::fence();
 }
 
-void h_gate(UINT target_qubit_index, StateVector& state) {
+void h_gate(UINT target_mask, UINT control_mask, StateVector& state) {
     Kokkos::parallel_for(
-        state.dim() >> 1, KOKKOS_LAMBDA(UINT it) {
-            UINT i = internal::insert_zero_to_basis_index(it, target_qubit_index);
+        state.dim() >> std::popcount(target_mask | control_mask), KOKKOS_LAMBDA(UINT it) {
+            UINT i = insert_zero_at_mask_positions(it, control_mask | target_mask) | control_mask;
             Complex a = state._raw[i];
-            Complex b = state._raw[i | (1ULL << target_qubit_index)];
+            Complex b = state._raw[i | target_mask];
             state._raw[i] = (a + b) * INVERSE_SQRT2();
-            state._raw[i | (1ULL << target_qubit_index)] = (a - b) * INVERSE_SQRT2();
+            state._raw[i | target_mask] = (a - b) * INVERSE_SQRT2();
         });
     Kokkos::fence();
 }
 
-void single_qubit_phase_gate(UINT target_qubit_index, Complex phase, StateVector& state) {
+void single_qubit_phase_gate(UINT target_mask,
+                             UINT control_mask,
+                             Complex phase,
+                             StateVector& state) {
     Kokkos::parallel_for(
-        state.dim() >> 1, KOKKOS_LAMBDA(UINT it) {
-            UINT i = internal::insert_zero_to_basis_index(it, target_qubit_index);
-            state._raw[i | (1ULL << target_qubit_index)] *= phase;
+        state.dim() >> std::popcount(target_mask | control_mask), KOKKOS_LAMBDA(UINT it) {
+            UINT i = insert_zero_at_mask_positions(it, control_mask | target_mask) | control_mask;
+            state._raw[i | target_mask] *= phase;
         });
     Kokkos::fence();
 }
 
-void s_gate(UINT target_qubit_index, StateVector& state) {
-    single_qubit_phase_gate(target_qubit_index, Complex(0, 1), state);
+void s_gate(UINT target_mask, UINT control_mask, StateVector& state) {
+    single_qubit_phase_gate(target_mask, control_mask, Complex(0, 1), state);
 }
 
-void sdag_gate(UINT target_qubit_index, StateVector& state) {
-    single_qubit_phase_gate(target_qubit_index, Complex(0, -1), state);
+void sdag_gate(UINT target_mask, UINT control_mask, StateVector& state) {
+    single_qubit_phase_gate(target_mask, control_mask, Complex(0, -1), state);
 }
 
-void t_gate(UINT target_qubit_index, StateVector& state) {
-    single_qubit_phase_gate(target_qubit_index, Complex(INVERSE_SQRT2(), INVERSE_SQRT2()), state);
+void t_gate(UINT target_mask, UINT control_mask, StateVector& state) {
+    single_qubit_phase_gate(
+        target_mask, control_mask, Complex(INVERSE_SQRT2(), INVERSE_SQRT2()), state);
 }
 
-void tdag_gate(UINT target_qubit_index, StateVector& state) {
-    single_qubit_phase_gate(target_qubit_index, Complex(INVERSE_SQRT2(), -INVERSE_SQRT2()), state);
+void tdag_gate(UINT target_mask, UINT control_mask, StateVector& state) {
+    single_qubit_phase_gate(
+        target_mask, control_mask, Complex(INVERSE_SQRT2(), -INVERSE_SQRT2()), state);
 }
 
-void sqrtx_gate(UINT target_qubit_index, StateVector& state) {
-    single_qubit_dense_matrix_gate(target_qubit_index, SQRT_X_GATE_MATRIX(), state);
+void sqrtx_gate(UINT target_mask, UINT control_mask, StateVector& state) {
+    single_qubit_dense_matrix_gate(target_mask, control_mask, SQRT_X_GATE_MATRIX(), state);
 }
 
-void sqrtxdag_gate(UINT target_qubit_index, StateVector& state) {
-    single_qubit_dense_matrix_gate(target_qubit_index, SQRT_X_DAG_GATE_MATRIX(), state);
+void sqrtxdag_gate(UINT target_mask, UINT control_mask, StateVector& state) {
+    single_qubit_dense_matrix_gate(target_mask, control_mask, SQRT_X_DAG_GATE_MATRIX(), state);
 }
 
-void sqrty_gate(UINT target_qubit_index, StateVector& state) {
-    single_qubit_dense_matrix_gate(target_qubit_index, SQRT_Y_GATE_MATRIX(), state);
+void sqrty_gate(UINT target_mask, UINT control_mask, StateVector& state) {
+    single_qubit_dense_matrix_gate(target_mask, control_mask, SQRT_Y_GATE_MATRIX(), state);
 }
 
-void sqrtydag_gate(UINT target_qubit_index, StateVector& state) {
-    single_qubit_dense_matrix_gate(target_qubit_index, SQRT_Y_DAG_GATE_MATRIX(), state);
+void sqrtydag_gate(UINT target_mask, UINT control_mask, StateVector& state) {
+    single_qubit_dense_matrix_gate(target_mask, control_mask, SQRT_Y_DAG_GATE_MATRIX(), state);
 }
 
-void p0_gate(UINT target_qubit_index, StateVector& state) {
-    single_qubit_dense_matrix_gate(target_qubit_index, PROJ_0_MATRIX(), state);
+void p0_gate(UINT target_mask, UINT control_mask, StateVector& state) {
+    single_qubit_dense_matrix_gate(target_mask, control_mask, PROJ_0_MATRIX(), state);
 }
 
-void p1_gate(UINT target_qubit_index, StateVector& state) {
-    single_qubit_dense_matrix_gate(target_qubit_index, PROJ_1_MATRIX(), state);
+void p1_gate(UINT target_mask, UINT control_mask, StateVector& state) {
+    single_qubit_dense_matrix_gate(target_mask, control_mask, PROJ_1_MATRIX(), state);
 }
 
-void rx_gate(UINT target_qubit_index, double angle, StateVector& state) {
+void rx_gate(UINT target_mask, UINT control_mask, double angle, StateVector& state) {
     const double cosval = std::cos(angle / 2.);
     const double sinval = std::sin(angle / 2.);
     matrix_2_2 matrix = {cosval, Complex(0, -sinval), Complex(0, -sinval), cosval};
-    single_qubit_dense_matrix_gate(target_qubit_index, matrix, state);
+    single_qubit_dense_matrix_gate(target_mask, control_mask, matrix, state);
 }
 
-void ry_gate(UINT target_qubit_index, double angle, StateVector& state) {
+void ry_gate(UINT target_mask, UINT control_mask, double angle, StateVector& state) {
     const double cosval = std::cos(angle / 2.);
     const double sinval = std::sin(angle / 2.);
     matrix_2_2 matrix = {cosval, -sinval, sinval, cosval};
-    single_qubit_dense_matrix_gate(target_qubit_index, matrix, state);
+    single_qubit_dense_matrix_gate(target_mask, control_mask, matrix, state);
 }
 
-void single_qubit_diagonal_matrix_gate(UINT target_qubit_index,
+void single_qubit_diagonal_matrix_gate(UINT target_mask,
+                                       UINT control_mask,
                                        const diagonal_matrix_2_2 diag,
                                        StateVector& state) {
     Kokkos::parallel_for(
         state.dim(),
-        KOKKOS_LAMBDA(UINT it) { state._raw[it] *= diag.val[(it >> target_qubit_index) & 1]; });
+        KOKKOS_LAMBDA(UINT it) { state._raw[it] *= diag.val[bool(it & target_mask)]; });
     Kokkos::fence();
 }
 
-void rz_gate(UINT target_qubit_index, double angle, StateVector& state) {
+void rz_gate(UINT target_mask, UINT control_mask, double angle, StateVector& state) {
     const double cosval = std::cos(angle / 2.);
     const double sinval = std::sin(angle / 2.);
     diagonal_matrix_2_2 diag = {Complex(cosval, -sinval), Complex(cosval, sinval)};
-    single_qubit_diagonal_matrix_gate(target_qubit_index, diag, state);
+    single_qubit_diagonal_matrix_gate(target_mask, control_mask, diag, state);
 }
 }  // namespace internal
 }  // namespace scaluq
diff --git a/scaluq/gate/update_ops_pauli.cpp b/scaluq/gate/update_ops_pauli.cpp
index 21ef7b0..6e6ea25 100644
--- a/scaluq/gate/update_ops_pauli.cpp
+++ b/scaluq/gate/update_ops_pauli.cpp
@@ -9,9 +9,17 @@
 
 namespace scaluq {
 namespace internal {
-void pauli_gate(const PauliOperator& pauli, StateVector& state) { pauli.apply_to_state(state); }
 
-void pauli_rotation_gate(const PauliOperator& pauli, double angle, StateVector& state) {
+// まだ
+void pauli_gate(UINT control_mask, const PauliOperator& pauli, StateVector& state) {
+    pauli.apply_to_state(state);
+}
+
+// まだ
+void pauli_rotation_gate(UINT control_mask,
+                         const PauliOperator& pauli,
+                         double angle,
+                         StateVector& state) {
     auto [bit_flip_mask_vector, phase_flip_mask_vector] = pauli.get_XZ_mask_representation();
     UINT bit_flip_mask = internal::BitVector(bit_flip_mask_vector).data_raw()[0];
     UINT phase_flip_mask = internal::BitVector(phase_flip_mask_vector).data_raw()[0];
diff --git a/scaluq/gate/update_ops_quantum_matrix.cpp b/scaluq/gate/update_ops_quantum_matrix.cpp
index 591cead..da879f1 100644
--- a/scaluq/gate/update_ops_quantum_matrix.cpp
+++ b/scaluq/gate/update_ops_quantum_matrix.cpp
@@ -15,17 +15,24 @@ matrix_2_2 get_IBMQ_matrix(double theta, double phi, double lambda) {
     return {cos_val, -exp_val2 * sin_val, exp_val1 * sin_val, exp_val1 * exp_val2 * cos_val};
 }
 
-void u1_gate(UINT target_qubit_index, double lambda, StateVector& state) {
-    single_qubit_dense_matrix_gate(target_qubit_index, get_IBMQ_matrix(0., 0., lambda), state);
+void u1_gate(UINT target_mask, UINT control_mask, double lambda, StateVector& state) {
+    single_qubit_dense_matrix_gate(
+        target_mask, control_mask, get_IBMQ_matrix(0., 0., lambda), state);
 }
 
-void u2_gate(UINT target_qubit_index, double phi, double lambda, StateVector& state) {
+void u2_gate(UINT target_mask, UINT control_mask, double phi, double lambda, StateVector& state) {
     single_qubit_dense_matrix_gate(
-        target_qubit_index, get_IBMQ_matrix(PI() / 2., phi, lambda), state);
+        target_mask, control_mask, get_IBMQ_matrix(PI() / 2., phi, lambda), state);
 }
 
-void u3_gate(UINT target_qubit_index, double theta, double phi, double lambda, StateVector& state) {
-    single_qubit_dense_matrix_gate(target_qubit_index, get_IBMQ_matrix(theta, phi, lambda), state);
+void u3_gate(UINT target_mask,
+             UINT control_mask,
+             double theta,
+             double phi,
+             double lambda,
+             StateVector& state) {
+    single_qubit_dense_matrix_gate(
+        target_mask, control_mask, get_IBMQ_matrix(theta, phi, lambda), state);
 }
 }  // namespace internal
 }  // namespace scaluq
diff --git a/scaluq/gate/update_ops_two_qubit.cpp b/scaluq/gate/update_ops_two_qubit.cpp
index 54dd2c6..47124db 100644
--- a/scaluq/gate/update_ops_two_qubit.cpp
+++ b/scaluq/gate/update_ops_two_qubit.cpp
@@ -8,12 +8,15 @@
 
 namespace scaluq {
 namespace internal {
-void swap_gate(UINT target0, UINT target1, StateVector& state) {
+void swap_gate(UINT target_mask, UINT control_mask, StateVector& state) {
+    UINT lower_target_mask = -target_mask & target_mask;
+    UINT upper_target_mask = target_mask ^ lower_target_mask;
     Kokkos::parallel_for(
-        1ULL << (state.n_qubits() - 2), KOKKOS_LAMBDA(UINT it) {
-            UINT basis = internal::insert_zero_to_basis_index(it, target0, target1);
-            Kokkos::Experimental::swap(state._raw[basis | (1ULL << target0)],
-                                       state._raw[basis | (1ULL << target1)]);
+        state.n_qubits() >> std::popcount(target_mask | control_mask), KOKKOS_LAMBDA(UINT it) {
+            UINT basis =
+                insert_zero_at_mask_positions(it, target_mask | control_mask) | control_mask;
+            Kokkos::Experimental::swap(state._raw[basis | lower_target_mask],
+                                       state._raw[basis | upper_target_mask]);
         });
     Kokkos::fence();
 }
diff --git a/scaluq/gate/update_ops_zero_qubit.cpp b/scaluq/gate/update_ops_zero_qubit.cpp
index fe13f51..11e5512 100644
--- a/scaluq/gate/update_ops_zero_qubit.cpp
+++ b/scaluq/gate/update_ops_zero_qubit.cpp
@@ -1,13 +1,16 @@
+#include "../util/utility.hpp"
 #include "update_ops.hpp"
 
 namespace scaluq {
 namespace internal {
-void i_gate(StateVector&) {}
+void i_gate(UINT, UINT, StateVector&) {}
 
-void global_phase_gate(double phase, StateVector& state) {
+void global_phase_gate(UINT, UINT control_mask, double phase, StateVector& state) {
     Complex coef = Kokkos::polar(1., phase);
     Kokkos::parallel_for(
-        state.dim(), KOKKOS_LAMBDA(UINT i) { state._raw[i] *= coef; });
+        state.dim() >> std::popcount(control_mask), KOKKOS_LAMBDA(UINT i) {
+            state._raw[insert_zero_at_mask_positions(i, control_mask) | control_mask] *= coef;
+        });
     Kokkos::fence();
 }
 }  // namespace internal
diff --git a/scaluq/util/utility.hpp b/scaluq/util/utility.hpp
index d4d7de3..209e612 100644
--- a/scaluq/util/utility.hpp
+++ b/scaluq/util/utility.hpp
@@ -39,6 +39,35 @@ KOKKOS_INLINE_FUNCTION UINT insert_zero_to_basis_index(UINT basis_index,
     return ((basis_index >> uidx) << (uidx + 1)) | (basis_index & umask);
 }
 
+/**
+ * Inserts multiple 0 bits at specified positions in basis_index.
+ * Example: insert_zero_to_basis_index(0b11111, 0x100101) -> 0b11011010.
+ *                                                               ^  ^ ^
+ */
+KOKKOS_INLINE_FUNCTION UINT insert_zero_at_mask_positions(UINT basis_index, UINT insert_mask) {
+    for (UINT bit_mask = insert_mask; bit_mask;
+         bit_mask &= (bit_mask - 1)) {  // loop through set bits
+        UINT lower_mask = ~bit_mask & (bit_mask - 1);
+        UINT upper_mask = ~lower_mask;
+        basis_index = ((basis_index & upper_mask) << 1) | (basis_index & lower_mask);
+    }
+    return basis_index;
+}
+
+inline UINT vector_to_mask(const std::vector<UINT>& v) {
+    UINT mask = 0;
+    for (auto x : v) mask |= 1ULL << x;
+    return mask;
+}
+
+inline std::vector<UINT> mask_to_vector(UINT mask) {
+    std::vector<UINT> indices;
+    for (UINT sub_mask = mask; sub_mask; sub_mask &= (sub_mask - 1)) {
+        indices.push_back(std::countr_zero(sub_mask));
+    }
+    return indices;
+}
+
 inline std::optional<ComplexMatrix> get_pauli_matrix(PauliOperator pauli) {
     ComplexMatrix mat;
     std::vector<UINT> pauli_id_list = pauli.get_pauli_id_list();
-- 
2.34.1

